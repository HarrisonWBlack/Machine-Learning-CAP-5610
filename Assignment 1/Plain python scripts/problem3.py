# -*- coding: utf-8 -*-
"""problem3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jibt0HUEPbeKPFBUxrOGdJ5MT4KAH9_b
"""

# Harrison Black
# HA435377
# CAP 5610
# UCF Spring 2019

# Problem 3
# Create network with an input layer consisting of 28 x 28 input neurons and an output layer consisting of 10 output neurons.

import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from keras.utils import to_categorical

# Load data set. 60000 training images, 10000 testing images
mnist = tf.keras.datasets.mnist
(training_imgs, training_labels), (test_imgs_og, test_labels) = mnist.load_data()
number_of_imgs, num_rows, num_columns = training_imgs.shape

# Reshape data set to vectors
training_imgs = (training_imgs.reshape(number_of_imgs, num_rows * num_columns, 1)).astype('float32') / 255
test_imgs = (test_imgs_og.reshape(len(test_imgs_og), num_rows * num_columns)).astype('float32') / 255
  
training_labels = to_categorical(training_labels)
test_labels = to_categorical(test_labels)
  
def softmax(z):
    softmax = np.exp(z) / np.exp(z).sum()
    return softmax
  
def cross_ent(a, y):
    return  -1 * np.dot(y.T, np.log10(a))

def cross_ent_prime(a, y, d):
  prime = np.dot(y.T, (a - d))
  return prime


# Image Classifier class
class ImageClassifier:
  def __init__(self):
    self.weights = np.random.normal(10)
    self.biases = np.random.normal(10)
  
  def model_training(self):
    
    learning_rate = 0.005

    for i in range(number_of_imgs):
      
      x = training_imgs[i].reshape(1, num_rows * num_columns)
      y = training_labels[i].reshape(1, 10)

      z = np.dot(x, self.weights) + self.biases
      a = softmax(z)
      loss = cross_ent(a, y)

      weight_gradient = np.dot(cross_ent_prime(a, y, np.identity(10)), x)
      bias_gradient = cross_ent_prime(a, y, np.identity(10)).T
      self.weights -= weight_gradient * learning_rate
      self.biases -= bias_gradient * learning_rate
      
  def prediction(self, x):
    prediction = np.argmax(softmax(self.weights.T.dot(x) + self.biases))
    return prediction
  
model = ImageClassifier()
model.model_training()